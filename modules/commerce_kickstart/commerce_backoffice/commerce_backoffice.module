<?php

// Until Entity API can load this itself.
require_once dirname(__FILE__) . '/commerce_backoffice.message.inc';

/**
 * Implements hook_views_api().
 */
function commerce_backoffice_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_backoffice') . '/views',
  );
}

/**
 * Implements hook_menu().
 */
function commerce_backoffice_menu() {
  // History tab on orders.
  $items['admin/commerce/orders/%commerce_order/history'] = array(
    'title' => t('History'),
    'page callback' => 'commerce_backoffice_order_history',
    'page arguments' => array(3),
    'access callback' => 'commerce_order_access',
    'access arguments' => array('view', 3),
    'type' => MENU_LOCAL_TASK,
    'weight' => 11,
  );
  // Megarow callbacks.
  $items['commerce_backoffice/order/%commerce_order'] = array(
    'title callback' => 'commerce_order_ui_order_title',
    'title arguments' => array(2),
    'page callback' => 'commerce_backoffice_order_view',
    'page arguments' => array(2),
    'delivery callback' => 'ajax_deliver',
    'access callback' => 'commerce_order_access',
    'access arguments' => array('view', 2),
  );
  $items['commerce_backoffice/variations/%node'] = array(
    'page callback' => 'commerce_backoffice_product_variations_view',
    'page arguments' => array(2),
    'delivery callback' => 'ajax_deliver',
    'access arguments' => array('administer commerce_product entities'),
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function commerce_backoffice_admin_paths() {
  // The order view should use the admin theme.
  $paths = array(
    'commerce_backoffice/view/*' => TRUE,
  );
  return $paths;
}

/**
 * Displays the complete history for the given order.
 */
function commerce_backoffice_order_history($order) {
  $arguments = array($order->order_id);
  $view = views_get_view('commerce_backoffice_order_messages');
  $view->set_display('block_1');
  $view->set_arguments($arguments);
  $view->override_url = $_GET['q'];

  return $view->preview();
}

/**
 * Displays the given order using the backoffice view mode, in a megarow.
 */
function commerce_backoffice_order_view($order) {
  $title = commerce_order_ui_order_title($order);
  $view = entity_view('commerce_order', array($order->order_id => $order), 'backoffice');
  $view = $view['commerce_order'][$order->order_id];
  $output = drupal_render($view);

  $return = views_megarow_display($title, $output, $order->order_id);
  if (!empty($view['#megarow_refresh_parent'])) {
    $return['#commands'][] = views_megarow_command_refresh_parent($order->order_id);
  }

  return $return;
}

/**
 * Displays a view of products referenced from the given node, in a megarow.
 */
function commerce_backoffice_product_variations_view($node) {
  $title = t('Variations for product %title', array('%title' => $node->title));
  $output = views_embed_view('commerce_backoffice_product_variations', 'default', $node->nid);

  return views_megarow_display($title, $output, $node->nid);
}

/**
 * Implements hook_form_views_form_alter().
 */
function commerce_backoffice_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['#node_edit_form'])) {
    $product_node_types = commerce_product_reference_node_types();
    if (in_array($form['#node']->type, array_keys($product_node_types))) {
      // Enable the #fieldset key.
      $form['#pre_render'][] = 'commerce_backoffice_pre_render_add_fieldset_markup';
      // Add a new vertical tab.
      $form['product_catalog'] = array(
        '#type' => 'fieldset',
        '#title' => t('Product catalog'),
        '#group' => 'additional_settings',
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#weight' => -10,
      );

      // Assign all taxonomy reference fields to the new vertical tab.
      foreach (field_info_instances('node', $form['#node']->type) as $field_name => $instance) {
        $field = field_info_field($field_name);

        if ($field['type'] == 'taxonomy_term_reference') {
          $form[$field_name]['#fieldset'] = 'product_catalog';
        }
      }
    }
  }
  // Alter the Exposed Filters for products page
  if (isset($form['submit']['#id']) && $form['submit']['#id'] == 'edit-submit-commerce-backoffice-products') {
    $form['product_display_node_type']['#attributes'] = array('data-placeholder' => array(t('All product types')));
    $form['term_node_tid_multiple_vocabularies']['#attributes'] = array('data-placeholder' => array(t('All categories')));
    $form['status']['#options']['All'] = t('All statuses');
    $form['combine']['#attributes'] = array('placeholder' => array(t('Search by title or SKU')));
  }
  // Alter the Exposed Filters for orders page
  if (isset($form['submit']['#id']) && $form['submit']['#id'] == 'edit-submit-commerce-backoffice-orders') {
    $form['status']['#attributes'] = array('data-placeholder' => array(t('All statuses')));
    $form['combine']['#attributes'] = array('placeholder' => array(t('Search by name, email, order ID')));
  }
}

/**
 * Implements hook_views_bulk_operations_form_alter().
 */
function commerce_backoffice_views_bulk_operations_form_alter(&$form, &$form_state, $vbo) {
  if ($form_state['step'] == 'views_form_views_form') {
    $form['select']['#title'] = '';
    $form['select']['#collapsible'] = FALSE;
    $form['select']['submit']['#value'] = t('Apply');
    $form['select']['operation']['#options'][0] = t('Bulk operations');
  }
}

/**
 * Implements hook_entity_info_alter().
 *
 * Adds a new order view mode, used to display the order in a megarow.
 */
function commerce_backoffice_entity_info_alter(&$entity_info) {
  $entity_info['commerce_order']['view modes']['backoffice'] = array(
    'label' => t('Backoffice'),
    'custom settings' => FALSE,
  );
}

/**
 * Implements hook_theme().
 */
function commerce_backoffice_theme(&$existing) {
  $themes =  array(
    'commerce_order__backoffice' => array(
      'path' => drupal_get_path('module', 'commerce_backoffice') . '/theme',
      'template' => 'commerce-order--backoffice',
    ),
  );

  return $themes;
}

/**
 * Add the template file for the backoffice view mode.
 */
function commerce_backoffice_preprocess_entity(&$vars) {
  if ($vars['entity_type'] == 'commerce_order' && $vars['view_mode'] == 'backoffice') {
    $vars['theme_hook_suggestions'][] = 'commerce_order__backoffice';
    $vars['classes_array'][] = 'commerce-order-backofffice';
  }
}

/**
 * Implements hook_views_pre_build().
 */
function commerce_backoffice_views_pre_build(&$view) {
  if ($view->name == 'commerce_backoffice_user_orders' && $view->current_display == 'order_page') {
    $view->display['order_page']->handler->options['title'] = _commerce_kickstart_user_page_title();
  }
}

/**
 * Implement hook_views_pre_render().
 */
function commerce_backoffice_views_pre_render(&$view) {
  if ($view->name == 'commerce_backoffice_orders') {
    drupal_add_css(drupal_get_path('module', 'commerce_backoffice') . '/theme/commerce-backoffice-order.css');
  }
  if ($view->name == 'commerce_backoffice_products') {
    drupal_add_css(drupal_get_path('module', 'commerce_backoffice') . '/theme/commerce-backoffice-products.css');
  }
}

/**
 * Implements hook_field_extra_fields().
 */
function commerce_backoffice_field_extra_fields() {
  $extra = array();
  $extra['commerce_order']['commerce_order'] = array(
    'display' => array(
      'status' => array(
        'label' => t('Status'),
        'description' => t('Allows the user to edit the status.'),
        'weight' => 0,
      ),
    ),
  );

  return $extra;
}

/**
 * Implements hook_entity_view().
 */
function commerce_backoffice_entity_view($entity, $entity_type, $view_mode, $langcode) {
  if ($entity_type == 'commerce_order' && $view_mode = 'backoffice') {
    $status_form = drupal_get_form('commerce_backoffice_status_form', $entity);
    // Bubble-up the signal for refreshing the parent row.
    if (!empty($status_form['#megarow_refresh_parent'])) {
      $entity->content['#megarow_refresh_parent'] = TRUE;
    }

    $markup = '<div class="field commerce-backoffice-order-status-form">';
    $markup .= '<div class="commerce-backoffice-order-status-label">' . t('Order status') . '</div>';
    $markup .= drupal_render($status_form);
    $markup .= '</div>';

    $entity->content['status'] = array(
      '#weight' => 10,
      '#markup' =>$markup,
      '#access' => commerce_order_access('update', $entity),
    );
  }
}

/**
 * Form callback: Returns the form for modifying the status column.
 */
function commerce_backoffice_status_form($form, &$form_state, $order) {
  $form_state['order'] = $order;

  if (!empty($form_state['order_saved'])) {
    // Show the status message on top of the form.
    drupal_set_message(t('The order status has been updated.'));
    $form['status_message'] = array(
      '#type' => 'markup',
      '#markup' => theme('status_messages'),
    );
    // Send the signal to reload the parent row.
    $form['#megarow_refresh_parent'] = TRUE;
  }

  $form['status'] = array(
    '#type' => 'select',
    '#title' => t('Status'),
    '#title_display' => 'invisible',
    '#options' => commerce_order_status_options_list(),
    '#default_value' => $order->status,
  );
  $form['save'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );

  return $form;
}

/**
 * Submit callback for commerce_backoffice_status_form.
 */
function commerce_backoffice_status_form_submit($form, &$form_state) {
  $order = $form_state['order'];
  $order->status = $form_state['values']['status'];
  commerce_order_save($order);

  $form_state['rebuild'] = TRUE;
  $form_state['order_saved'] = TRUE;
}

/**
 * Form callback: Returns the form for modifying the product price and status.
 */
function commerce_backoffice_product_quick_edit_form($form, &$form_state, $product) {
  $form_state['product'] = $product;

  $price_array = $product->commerce_price[LANGUAGE_NONE][0];
  $price = commerce_currency_amount_to_decimal($price_array['amount'], $price_array['currency_code']);

  $wrapper = drupal_html_id('commerce-backoffice-product-quick-edit-form');
  $form['#prefix'] = '<div class="container-inline" id="' . $wrapper . '">';
  $form['#suffix'] = '</div>';

  $form['price'] = array(
    '#type' => 'textfield',
    '#title' => t('Price'),
    '#title_display' => 'invisible',
    '#default_value' => sprintf("%.2f", $price),
    '#size' => 5,
  );
  $form['status'] = array(
    '#type' => 'select',
    '#title' => t('Status'),
    '#title_display' => 'invisible',
    '#options' => array(0 => t('Disabled'), 1 => t('Enabled')),
    '#default_value' => $product->status,
  );
  $form['save'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#ajax' => array(
      'callback' => 'commerce_backoffice_product_quick_edit_form_ajax',
      'wrapper' => $wrapper,
    ),
  );
  if (!empty($form_state['product_saved'])) {
    $form['save']['#suffix'] = t('Saved');
  }

  return $form;
}

/**
 * Ajax callback for commerce_backoffice_product_quick_edit_form.
 */
function commerce_backoffice_product_quick_edit_form_ajax($form, &$form_state) {
  return $form;
}

/**
 * Submit callback for commerce_backoffice_product_quick_edit_form.
 */
function commerce_backoffice_product_quick_edit_form_submit($form, &$form_state) {
  $product = $form_state['product'];
  $currency_code = $product->commerce_price[LANGUAGE_NONE][0]['currency_code'];
  $product->commerce_price[LANGUAGE_NONE][0]['amount'] = commerce_currency_decimal_to_amount($form_state['values']['price'], $currency_code);
  $product->status = $form_state['values']['status'];
  commerce_product_save($product);

  $form_state['rebuild'] = TRUE;
  $form_state['product_saved'] = TRUE;
}

/**
 * Implements hook_commerce_order_update().
 */
function commerce_backoffice_commerce_order_update($order) {
  commerce_backoffice_statistics_reset();
}

/**
 * Implements hook_commerce_order_insert().
 */
function commerce_backoffice_commerce_order_insert($order) {
  commerce_backoffice_statistics_reset();
}

/**
 * Rebuild the statistics for orders.
 */
function commerce_backoffice_statistics_reset() {
  drupal_static_reset('commerce_backoffice_statistics');
  cache_clear_all('commerce_order_statistics', 'cache');
}

/**
 * Get the statistics for orders.
 */
function commerce_backoffice_statistics() {
  $statistics = &drupal_static(__FUNCTION__, array());

  if (empty($statistics)) {
    $cache = cache_get('commerce_order_statistics', 'cache');
    if ($cache) {
      $statistics = $cache->data;
    }
  }
  if (empty($statistics)) {
    foreach (commerce_order_states() as $state_name => $state_info) {
      $statistics['by state'][$state_name] = 0;
      foreach (commerce_order_statuses(array('state' => $state_name)) as $status_name => $status_info) {
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', 'commerce_order');
        $query->propertyCondition('status', $status_name);
        $query->count();
        $statistics['by status'][$status_name] = $query->execute();
        $statistics['by state'][$state_name] += $statistics['by status'][$status_name];
      }
    }
    cache_set('commerce_order_statistics', $statistics, 'cache');
  }
  return $statistics;
}

/**
 * Implements hook_flush_caches().
 */
function commerce_backoffice_flush_caches() {
  commerce_backoffice_message_field_refresh();
}

/**
 * Move form elements into fieldsets for presentation purposes.
 *
 * Entity forms use #tree = TRUE to keep their values in a hierarchy for
 * easier storage. Moving the form elements into fieldsets during form building
 * would break up that hierarchy, so it's not an option for Field API fields.
 * Therefore, we wait until the pre_render stage, where any changes we make
 * affect presentation only and aren't reflected in $form_state['values'].
 */
function commerce_backoffice_pre_render_add_fieldset_markup($form) {
  $sort = array();
  foreach (element_children($form) as $key) {
    $element = $form[$key];
    // In our form builder functions, we added an arbitrary #fieldset property
    // to any element that belongs in a fieldset. If this form element has that
    // property, move it into its fieldset.
    if (isset($element['#fieldset']) && isset($form[$element['#fieldset']])) {
      $form[$element['#fieldset']][$key] = $element;
      // Remove the original element this duplicates.
      unset($form[$key]);
      // Mark the fieldset for sorting.
      if (!in_array($key, $sort)) {
        $sort[] = $element['#fieldset'];
      }
    }
  }

  // Sort all fieldsets, so that element #weight stays respected.
  foreach ($sort as $key) {
    uasort($form[$key], 'element_sort');
  }

  return $form;
}
